# 关于流水线冒险

指令序列中，某些特殊情况可能会使流水线无法正常进行，此时需要对流水线进行停顿或者冲刷处理。流水线冒险分三种：

## 1. 结构冒险

结构冒险，即硬件资源冲突。如果在某个周期，同一个硬件资源同时被不同指令使用，就会引发结构冒险。被竞争的硬件资源可以是寄存器、存储器或总线等。

**示例（待补全）**：如果不区分指令存储器和数据存储器，或者寄存器的读写端口没有分开...

在YADAN中，取指和访存阶段均需要访问AHB总线，可能发生结构冒险，从而引起流水线停顿。发起停顿的逻辑由总线接口 `cpu_ahb_if.v` 和 `cpu_ahb_mem.v` 进行处理。

其中，`cpu_ahb_if`对应的是总线对ROM的访问接口, `cpu_ahb_mem.v` 对应的是总线对RAM的访问接口。处理方式如下：
1.  使能信号的使用。RAM和ROM使能信号在例化时呈现互补的状态，确保在同一时刻下只能有一方使能工作。
`.PCchange_enable(~ram_ce_o)`
2.  接口处四段式状态机的使用。接口模块会根据当前使能状态来决定跳转的下一状态。对于RAM来说，每当其使用并占用总线时，都会发送流水线停顿信号，避免访存过程中ROM被调用导致的结构冒险；对于ROM来说，在其未使能或者未占用总线时，都会发送流水线停顿信号，确保取指过程以及流水线的有序进行。
3.  AHB协议的使用。取值和访存过程对总线的使用由AHB总线协议来约束，当发送总线请求后，会通过`M_HGRANT`仲裁是否允许使用总线，通过置位`M_HBUSREQ`告知总线此时工作状态，对于RAM来说，还会通过判断`M_HREADY`来决定是否结束当前工作并停止发送流水线停顿信号，将总线使用权交还给ROM。


## 2. 数据冒险

数据冒险，或者叫数据依赖。如果某条指令需要用到前面指令的结果时，前面指令的结果还未产生，就会引发数据冒险。

**示例（待补全）**：前面的指令写结果之前，后面的指令就需要读取数据，如果不采取任何措施，后者就无法读取到正确的值。这种数据冒险叫做写后读（RAW）冒险。在非乱序执行的流水线中，所有数据冒险都是RAW造成的。

对于RAW数据冒险，有以下几种解决方法：

1. 编译时插入空操作指令
2. 发起流水线停顿
3. 采用旁路技术

在YADAN中，对RAW数据冒险的处理优先采用旁路技术，在某种特殊情况下，发起流水线停顿。

（待画图详细说明）

## 3. 控制冒险

控制冒险，或者叫分支冒险。正常情况下，指令在流水线中总是按顺序执行。当遇到分支指令或跳转指令时，指令执行顺序被强行改变，需要特殊处理。

在 `ex` 阶段执行指令后，得到当前是否跳转的结论，产生 `branch_flag` 和 `branch_addr` 两个信号。当 `branch_flag` 为 1（即需要跳转）时，需要清除当前处于 `if` 和 `id` 阶段的指令（正在顺序执行的指令），并通过改变 `pc` 进行跳转。

- 将 `branch_flag` 信号接入 `if_id`，用于清除 `if` 阶段取到的指令 `inst_o`；
- 将 `branch_flag` 信号接入 `id_exe`，用于清除译码结果；
- 将 `branch_flag` 和 `branch_addr` 信号接入 `pc_reg`，用于改变 `pc` 实现跳转。

# 关于流水线停顿

在以下情况发生时，需要发起流水线停顿，以某种方式将流水线暂停下来。

- 取指和访存阶段需要访问总线，可能发生结构冒险，从而请求流水线停顿，等待总线的仲裁和访问；
- 译码阶段在处理数据冒险时，可能请求流水线停顿，等待上一条指令的执行；
- 执行阶段在进行乘除法运算时，可能需要占用多个时钟周期，从而请求流水停顿。

要使流水线停顿，一种简单的实现方法是：假如流水线第 `n` 阶段请求流水线停顿，那么需要保持 `pc` 值不变，同时使第 `n` 阶段及其之前的各阶段暂停更新，而处于第 `n` 阶段之后的指令则继续运行。

`ctrl` 模块根据各模块传来的停顿请求，产生一个六位的流水线停顿信号 `stalled[4:0]`，从低位到高位分别对应暂停更新 `pc`，暂停取指，暂停译码，暂停执行和暂停访存。写回阶段不会被暂停。各级的暂停处理均写在时序逻辑模块中。

- **pc更新**
  - `pc_reg`模块：`stalled[0]`为1时，停止更新 `pc`
- **取指**
  - `if_id`模块：`stalled[1]`为1时，考虑 `stalled[2]` 是否也为1，即译码阶段是否停顿：
    - 若译码阶段也停顿，停止更新传递到译码阶段的指令
    - 若译码阶段不停顿，清除传递到译码阶段的指令（置为空指令）
- **译码**
  - `id_ex`模块：`stalled[2]`为1时，考虑 `stalled[3]` 是否也为1，即执行阶段是否停顿：
    - 若执行阶段也停顿，停止更新传递到执行阶段的译码结果
    - 若执行阶段不停顿，清除译码结果（置为空指令）
- **执行**
  - `ex_mem`模块：`stalled[3]`为1时，考虑 `stalled[4]` 是否也为1，即访存阶段是否停顿：
    - 若执行阶段也停顿，停止更新传递到访存阶段的执行结果
    - 若执行阶段不停顿，清除执行结果
- **访存**
  - `mem_wb`模块：`stalled[4]`为1时，停止更新传递到回写阶段的访存结果

注意，在 `pc_reg` 模块中，改变 `pc` 实现跳转的分支必须优先于是否停顿的判断。否则，如果在取指阶段发生流水线停顿，执行阶段不受影响，继续更新跳转信号，`pc_reg` 却不能及时根据执行阶段发来的跳转信号更新 `pc`，跳转信号将会因此丢失。
# 第一章 处理器概述

## 1.1 引言：探索处理器的奥秘与价值

随着时代的车轮滚滚向前，计算机技术已成为现代社会不可或缺的支柱。它赋予了人类前所未有的能力，极大地拓宽了人类认知与实践的边界——通过编程，我们能够驾驭庞大的数据，进行复杂的计算和深入的分析。你可能会好奇，这些强大的计算机究竟是如何运转的？如何构建一个专属于自己的处理器，并在它上面运行你精心编写的程序？

幸运的是，RISC-V这一开源指令集的迅猛发展，以其大道至简的特性，大大降低了学习CPU设计的技术门槛。本书将以将YADAN SoC作为RISC-V架构CPU的设计案例，带你深入处理器的内部世界，揭示其设计原理，并指导你如何一步步搭建起自己的RISC-V CPU处理器。

通过阅读本书，你不仅能够获得对处理器设计更深层次的理解，还能亲手实现一个属于你自己的计算核心，开启一段激动人心的创造之旅。

## 1.2 在YADAN上实现呼吸灯

由Verimake设计的YADAN项目是一个综合性的硬件设计学习平台，它由YADAN Core、YADAN SoC和YADAN Board三个核心组件构成。YADAN Core是基于RISC-V指令集的CPU内核，而YADAN SoC则是围绕这个CPU内核构建的片上系统（SoC，System on Chip），集成多种外设，允许开发者根据需求进行灵活配置。YADAN Board则是一个搭载有Anlogic FPGA的开发板，YADAN SoC可以被部署在其上，为学习和实践提供一个实际的硬件平台。[YADAN 主文档：docs.yadanboard.com](http://docs.yadanboard.com/)

接下来，我们将通过一个简单的示例程序，演示如何在YADAN Board上实现呼吸灯效果，从而初步探索计算机系统的基本工作机制。对于那些渴望亲自动手尝试的读者，YADAN Board的获取和环境配置指南可以在官方文档中找到。

### 1.2.1 C语言示例程序

以下是一个用C语言编写的简单程序，用于在YADAN Board的GPIO第13号引脚上实现呼吸灯效果。程序通过控制GPIO引脚的高低电平以及延时来模拟PWM（脉冲宽度调制）控制，实现LED的亮度调节。

```c
// 宏定义简化对寄存器的访问
#define REG(add) (*(volatile unsigned int *)(add))

// 定义GPIO寄存器地址
#define PADDIR REG(0x4A101000) 	// GPIO方向寄存器
#define PADOUT REG(0x4A101008)  // GPIO输出寄存器


int main()
{
    PADDIR |= (1 << 13);	// 设置GPIO的第13号引脚为输出模式
    int num = 850; 			// 定义控制呼吸效果的周期数
    while (1) 				// 主循环
    {
        // 呼吸灯渐亮过程：逐渐增加LED闪烁时的点亮时间
        for (int j = 0; j < num; j++)
        {
            PADOUT |= (1 << 13); 				// 设置GPIO第13号引脚为高电平，点亮LED
            for (int i = 0; i < j; i++)			// 软件延时，延时时间随j的增加而增加
                ;
            PADOUT &= ~(1 << 13); 				// 设置GPIO第13号引脚为低电平，熄灭LED
            for (int i = 0; i < num - j; i++)	// 软件延时
                ;
        }

        // 呼吸灯渐暗过程：逐渐减少LED闪烁时的点亮时间
        for (int j = num; j > 0; j--)
        {
            PADOUT |= (1 << 13);
            for (int i = j; i > 0; i--)
                ;
            PADOUT &= ~(1 << 13);
            for (int i = num - j; i > 0; i--)
                ;
        }
    }

    return 0; // 此行通常不会被执行
}
```

呼吸灯效果的实现依赖于精确控制LED的闪烁周期和占空比，这通常通过延时控制来完成。在每个周期内，LED被点亮的时间长度（即高电平的持续时间）决定了人眼感知到的亮度。

延时可以通过软件循环来实现，也可以通过定时器来实现。本示例程序采用了软件循环延时的方法，主要是出于简化实现和便于理解的考虑。如果不希望占用CPU资源，或对时间精度要求较高，考虑使用定时器实现硬件层面的延时。

### 1.2.2 从C语言到机器码

上文中的C语言程序看起来直观易懂，但硬件本身并不直接执行这种高级语言。硬件只能执行由二进制数字组成的机器码(Machine Code)。机器码中的每个二进制数字都严格对应于处理器的指令集架构（ISA，Instruction Set Architecture）中定义的具体操作。将C语言代码通过编译（广义）转换为硬件能够执行的机器码，需要经历以下一系列的步骤：

1. **预处理**：编译器首先处理代码中的预处理指令，如宏定义的展开和条件编译指令，为编译阶段准备源代码。
2. **编译（狭义）**：编译器将C语言代码转换成汇编语言。这一过程将高级语言中的抽象行为转换为与特定ISA兼容的低级指令，即汇编指令，仍保持一定的可读性。编译时，开发者需要指定目标硬件平台。
3. **汇编**：汇编器将汇编语言进一步转换成机器码。这一过程将文本形式的汇编指令转换为二进制形式的机器指令，这些指令是直接由硬件执行的具体操作。
4. **链接**：链接器将分散的代码模块和库函数合并起来，形成一个单一的可执行文件。这个过程涉及到解决代码中的外部引用，确保所有依赖的代码段和数据段被正确地组织在最终的可执行文件中。
5. 最终生成的可执行文件包含了所有必要的机器码，以及所有必要的元数据，如程序的入口点和其他硬件所需的信息。这些元数据确保了程序能够在目标硬件上正确地初始化和执行。

整个编译过程涉及到编译器、汇编器和链接器等工具，它们共同工作，将高级语言代码转换成特定硬件能够理解和执行的低级指令。这一过程还必须考虑到目标硬件平台的特定架构和资源限制，以确保生成的代码既高效又适合在该硬件上运行。

### 1.2.3 编译与观察编译过程

以上的一系列工作可以通过特定的工具链来完成，这些工具链是专门为不同的硬件平台和指令集架构设计的。对于RISC-V架构的CPU，RISC-V GCC工具链能够面向其生成可执行的机器码。除此之外，工具链还包括了调试器、仿真器等辅助开发的工具，它们为开发者提供了代码调试、运行时错误检测和性能分析等功能。下面我们以跨平台RISC-V GCC工具链 The xPack GNU RISC-V Embedded GCC 为例，试着编译上面以C语言编写的呼吸灯程序`main.c`。

#### 1.2.3.1 预处理（Preprocess）

预处理是编译过程的第一个阶段，它主要负责处理源代码文件中的预处理指令，如宏定义、文件包含等。在终端中，使用以下命令对 `main.c` 进行单独的预处理：

```
riscv-none-embed-gcc -march=rv32imc -mabi=ilp32 -E -o main.i main.c
```

**参数解释**

上面的命令中，`riscv-none-embed-gcc`是我们所运行的编译器，`none-embed` 表示该编译器用于嵌入式系统，不依赖于特定的操作系统。

- `-march=rv32imc`：指定目标架构为 RISC-V 32位处理器，并支持整数（I）、乘法和除法（M）以及压缩（C）指令集扩展。
- `-mabi=ilp32`：指定应用二进制接口（ABI），这里 `ilp32` 表示 32 位整型（`int`）、长整型（`long`）、指针（`pointer`）都使用 32 位，适用于不支持浮点扩展指令的 YADAN Core。
- `-E`：指示编译器只执行预处理步骤，不进行编译、汇编或链接。这对于调试和查看宏定义如何影响源代码非常有用。
- `-o main.i`：指定输出文件的名称，预处理后的文件将被命名为 `main.i`。
- `main.c`：指定源代码文件。

**预处理结果**

以下是预处理命令生成的`main.i`文件的内容：

```c
# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"
# 9 "main.c"
int main()
{
    (*(volatile unsigned int *)(0x4A101000)) |= (1 << 13);
    int num = 850;
    while (1)
    {

        for (int j = 0; j < num; j++)
        {
            (*(volatile unsigned int *)(0x4A101008)) |= (1 << 13);
            for (int i = 0; i < j; i++)
                ;
            (*(volatile unsigned int *)(0x4A101008)) &= ~(1 << 13);
            for (int i = 0; i < num - j; i++)
                ;
        }


        for (int j = num; j > 0; j--)
        {
            (*(volatile unsigned int *)(0x4A101008)) |= (1 << 13);
            for (int i = j; i > 0; i--)
                ;
            (*(volatile unsigned int *)(0x4A101008)) &= ~(1 << 13);
            for (int i = num - j; i > 0; i--)
                ;
        }
    }

    return 0;
}
```

得到的 `main.i` 文件仍是C语言程序，与原始的 `main.c` 文件相比，有几个显著的变化：

- **宏展开**：所有`#define`宏定义，如 `REG`、`PADDIR` 和 `PADOUT`，都被替换为它们的实际值或表达式。

- **注释删除**：源代码中的所有注释（包括单行和多行注释）在预处理后被删除，因为它们对编译器来说是不必要的。

- **预处理器指令**：预处理器添加了一些指令，如文件和行号信息，用于在调试过程中帮助定位原始代码。

此外，如果源代码中包含 `#include` 指令，预处理器会将被包含的文件内容插入到该指令的位置，递归地展开所有包含的文件。

值得注意的是，预处理步骤不检查源代码的语法正确性，仅执行预处理指令。因此，如果源代码中存在语法错误，这些错误将不会被预处理步骤发现，而会在后续的编译步骤中被编译器捕获。

#### 1.2.3.2 编译（Compile）

在终端中，使用以下命令对 `main.i` 进行编译：

```
riscv-none-embed-gcc -march=rv32imc -mabi=ilp32 -S -o main.s main.i
```

参数 `-S` 指示编译器在编译过程中跳过汇编步骤，直接生成汇编语言文件（`*.s`）。这一步生成的 `main.s` 文件包含了源代码对应的汇编指令。

打开 `main.s` 文件，我们可以查看编译器生成的汇编代码。这些代码是RISC-V架构的低级表示，可能对初学者来说有些难以理解。但不用担心，我们会在后续的***某节（待补充）***中详细讲解RISC-V指令集的基础知识。

现在，让我们逐段分析编译产生的汇编代码的含义：

**全局设置，函数入口与栈帧设置**

```assembly
	.file	"main.c"		# 文件信息：指示汇编代码来源于 main.c 文件
	.option nopic			# 编译选项：不使用 PIC（位置无关代码）
	.text					# 指示接下来的部分是可执行代码（文本段）
	.align	1				# 确保代码的对齐，以满足内存访问要求
	.globl	main			# 声明 main 为全局符号，可在其他编译单元引用
	.type	main, @function
main:						# 函数入口：表示 main 函数的开始
	addi	sp,sp,-48		# 调整栈指针 sp，为局部变量分配48字节的栈空间
	sw	s0,44(sp)			# 将原来的栈指针 s0 保存到栈中，建立新的栈帧
	addi	s0,sp,48		# 更新帧指针 s0 指向新的栈帧底部，为局部变量访问提供基地址
```

这些步骤在C语言的高级抽象中通常是不可见的，因为它们是由编译器自动处理的底层细节，程序员通常不需要关心。然而，在汇编语言级别，每个操作都明确地反映了CPU如何与内存交互，以及如何管理栈帧。

**初始化 GPIO 方向寄存器**

```assembly
	li	a5, 1242566656      # 加载 PADDIR 寄存器的地址到寄存器 a5
	lw	a3, 0(a5)           # 从 PADDIR 地址加载当前值到 a3
	li	a5, 1242566656      # 重新加载 PADDIR 寄存器地址
	li	a4, 8192            # 加载 (1 << 13) 的值到 a4
	or	a4, a3, a4          # 将 a3 和 a4 的值进行逻辑或操作，设置 a4 的第 13 位为1
	sw	a4, 0(a5)           # 将更新后的值写回 PADDIR
```

这一段汇编指令完成了C代码中 `PADDIR |= (1 << 13);` 这一行代码的功能。可以看出，虽然初始化GPIO方向寄存器在C语言中只需简单的位或操作，但在汇编层面，它涉及到多个步骤，包括加载地址、读取当前值、修改位和写回新值。

**初始化控制变量**

```assembly
li	a5, 850             	# 设置 a5，即循环控制变量 num 的值为850
sw	a5, -44(s0)         	# 将 num 存入栈帧中
```

**主循环：LED 呼吸效果**

主循环在增加和减少 LED 亮度之间交替。

渐亮阶段

```assembly
.L14:						# 主循环开始
    sw	zero, -20(s0)       # 初始化外层循环计数器 j
    j	.L2                 # 跳转到外层循环条件检查
.L7:
    li	a5, 1242566656      # 加载 PADOUT 的基地址到 a5
    addi	a5, a5, 8       # 计算 PADOUT 地址
    lw	a3, 0(a5)           # 加载 PADOUT 的当前值
    li	a5, 1242566656
    addi	a5, a5, 8
    li	a4, 8192            # 加载 (1 << 13) 的值
    or	a4, a3, a4          # 设置 PADOUT 的第 13 位
    sw	a4, 0(a5)           # 写回 PADOUT 以点亮 LED
    sw	zero, -24(s0)       # 初始化第一个延时计数器 i
    j	.L3                 # 跳转到第一个延时循环条件检查
.L4:
    lw	a5, -24(s0)         # 加载第一个延时计数器 i
    addi	a5, a5, 1       # 增加 i
    sw	a5, -24(s0)         # 存储增加后的 i
.L3:
    lw	a4, -24(s0)         # 加载第一个延时计数器 i
    lw	a5, -20(s0)         # 加载外层循环计数器 j
    blt	a4, a5, .L4         # 如果 i < j，重复延时循环，否则延时结束，向下执行
    li	a5, 1242566656
    addi	a5, a5, 8
    lw	a3, 0(a5)           # 加载 PADOUT 的当前值
    li	a5, 1242566656
    addi	a5, a5, 8
    li	a4, -8192           # 准备清除 PADOUT 的第 13 位
    addi	a4, a4, -1      # 确保掩码正确
    and	a4, a3, a4          # 清除 PADOUT 的第 13 位
    sw	a4, 0(a5)           # 写回 PADOUT 以熄灭 LED
    sw	zero, -28(s0)       # 初始化第二个延时计数器 j
    j	.L5                 # 跳转到第二个延时循环条件检查
.L6:
    lw	a5, -28(s0)         # 加载第二个延时计数器 i
    addi	a5, a5, 1       # 增加 i
    sw	a5, -28(s0)         # 存储增加后 i
.L5:
    lw	a4, -44(s0)         # 加载常量 num
    lw	a5, -20(s0)         # 加载循环计数器 j
    sub	a5, a4, a5         	# 计算 num - j
    lw	a4, -28(s0)         # 加载第二个延时计数器 i
    blt	a4, a5, .L6         # 如果 i < num - j，重复延时循环，否则延时结束，向下执行
    lw	a5, -20(s0)         # 加载循环计数器 j
    addi	a5, a5, 1       # 增加 j
    sw	a5, -20(s0)         # 存储增加后的 j
.L2:
    lw	a4, -20(s0)         # 加载循环计数器 j
    lw	a5, -44(s0)         # 加载常量 num
    blt	a4, a5, .L7         # 如果 j < num，重复渐亮阶段，否则循环结束，向下执行

```

这部分代码使呼吸灯逐渐变亮，包含三层嵌套循环，分别是最内层的两个延时循环，管理延时时间的外层循环，和最外层的主循环。

- 主循环从标签 `.L14`开始，对应C语言源代码中的 `while(1)`。

- 外层循环从标签 `.L7`开始，通过改变计数器 `j` 的值来改变延时循环的循环次数，管理亮度的增加。

- 延时循环从标签 `.L4` 和 `L6` 开始，以 `i` 为循环计数器，为LED的点亮和熄灭实现延时效果。

渐暗阶段

```assembly
	lw	a5, -44(s0)         # 加载 num
    sw	a5, -32(s0)         # 用 num 初始化外层循环计数器 j
    j	.L8                 # 跳转到外层循环条件检查
.L13:
    li	a5, 1242566656
    addi	a5, a5, 8
    lw	a3, 0(a5)
    li	a5, 1242566656
    addi	a5, a5, 8
    li	a4, 8192
    or	a4, a3, a4
    sw	a4, 0(a5)         
    lw	a5, -32(s0)    
    sw	a5, -36(s0)
    j	.L9                 
.L10:
    lw	a5, -36(s0)       
    addi	a5, a5, -1      
    sw	a5, -36(s0)       
.L9:
    lw	a5, -36(s0)       
    bgtz	a5, .L10        
    li	a5, 1242566656    
    addi	a5, a5, 8       
    lw	a3, 0(a5)         
    li	a5, 1242566656    
    addi	a5, a5, 8
    li	a4, -8192
    addi	a4, a4, -1
    and	a4, a3, a4
    sw	a4, 0(a5)
    lw	a4, -44(s0)
    lw	a5, -32(s0)
    sub	a5, a4, a5
    sw	a5, -40(s0)
    j	.L11
.L12:
    lw	a5, -40(s0)
    addi	a5, a5, -1
    sw	a5, -40(s0)
.L11:
    lw	a5, -40(s0)
    bgtz	a5, .L12
    lw	a5, -32(s0)
    addi	a5, a5, -1
    sw	a5, -32(s0)
.L8:
    lw	a5, -32(s0)
    bgtz	a5, .L13        # 如果 j > 0，重复渐暗阶段
    j	.L14                # 跳回亮起阶段开始
```

这部分代码仍处于主循环之内，类似地，由外层循环管理延时时间，并包含两个延时循环，使呼吸灯逐渐变暗。

**函数大小和版本信息**

```assembly
.size	main, .-main
.ident	"GCC: (GNU MCU Eclipse RISC-V Embedded GCC, 64-bit) 8.2.0"
```

这些指令提供了`main`函数的大小和编译器的版本信息。

汇编代码展示了C语言源代码被转换成机器可执行指令的详细过程。理解汇编代码有助于深入学习计算机系统的工作方式，包括寄存器操作、栈管理、循环控制等。



通过这一系列精细的步骤，即便是简单的呼吸灯效果，也体现了高级语言的抽象能力和硬件底层实现的强大协同效应。这不仅展示了软件定义功能的灵活性，也彰显了硬件执行效率的重要性。





机器码是一种低级语言，与C语言等高级语言相比，它缺乏可读性和可移植性，高度依赖于特定的硬件架构。机器码中的每个二进制数字都直接对应于处理器指令集架构（ISA）中预定义的具体操作，它一旦生成就与目标处理器或微控制器形成了紧密的绑定。
